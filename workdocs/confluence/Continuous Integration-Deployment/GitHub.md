## GitHub

## Branch protection

### Templates

 - Bug (should match the same fields as the `bug` ticket)
 - Feature (should match the same fields as the `feature` ticket)
 - Incident (should match the same fields as the `incident` ticket)

### Issues

Issues in GitHub are only used for user/client connection to the project (when client in not in Jira).

Opening an Issue should:

 - use a predefined template;
 - must be able to extract information matching the corresponding Jira ticket's fields
 - if the issue is not parseable or not all mandatory Jira field ticket are present, reject the issue giving the reason to the user

For bugs:
 - Open a `bug` ticket in Jira

For feature requests:
 - Open a `feature` ticket in Jira

For incidents:
 - Open an `incident` ticket in Jira

### Actions

#### Caches

 - dependencies: key: `<repo>-dependencies-<branch>` - store the cached npm dependencies. update triggered by change of `package-lock.json`
 - build: key: `<repo>-build-<branch>` - store compiled code. update triggered by change of `src`/`tests`/`ts-config`/`package-lock.json`
 - test: key: `<repo>-test-<branch>` - store test results. update triggered by change of `tests`/`workdocs/reports/jest-reports.config.ts`/`package-lock.json`


#### ***Triggerable***
actions that can be triggered by authorized user

##### Release
 - manual - options `validated`, `dev`
 - On PR (tech leads can bypass approval for non validated/'non released' releases):
   - if user `external` or in the first `n` PRs of contributor:
     - request approval before CI (ideally in jira);
   - merge master with branch
   - Build code (analog to `build`/`build:prod` depending on `dev` or not = debuggable containers/maps + readable code on source files);
   - Run Linting (analog to `lint`);
   - Run Code Coverage (analog to `coverage`) - should show results integrated in GitHub;
   - Test doc generation (analog to `docs`);
   - Request approval (ideally in jira):
     - from tech-lead/administration + quality/administration on code and doc files (one of each, non repeating, different from submitter)
     - from tech-lead/administration + quality/administration on code, style and doc files (one of each, non repeating, different from submitter)
     - from administration on codeowners or funding files
   - Create validation report (optional):
     - assign `fix version` to closed tickets 
     - create version matrix (autogenerated from template);
     - create dependency matrix (autogenerated from template);
     - create release notes (autogenerated from template):
       - breaking changes/upgrade guide (link to confluence design spec breaking changes info for version)
       - new features (exported from Jira via JQL)
       - fixed bugs (exported from Jira via JQL)
       - known issues (exported from Jira via JQL)
     - update confluence
     - Create IQ Jira Ticket (from template):
       - fill data from previous steps;
     - Request validation from pm/administrators and quality/administrators (1 each, non repeating)
     - generate new tag (path/minor/version from if breaking changes files being populated or from highest ticket level. bug = patch, feature = minor, breaking change = major)
     - Generate Confluence Validation/Certification report with:
       - version matrix;
       - dependency matrix;
       - release notes;
     - Request signatures (Quality)
   - merge to master
     - add link to confluence validation report
     - add md version of release notes
     - add dependency matrix
     - add version matrix
     - add package hash
     - generate GitHub release (optional):
   - publish:
     
##### Publish
- npm:
  - create package
- docker:
    - create dev image (if not validated), standard image otherwise

##### Deploy
 - manual - options `dev`, `tag` (if in dev no deployment loop - just runs for dev)
 - on Publish - inherit options
 - loop `dev` -> `tst` -> `prod` -> `demo` (if not in dev):
   1. create IQ (from template):
     1. fill from previous data
     2. request approvals from quality/administration + CI/administration (one each non repeating)
     3. deploy/update environment
     4. run e2e tests against environment
        1. aggregate evidences
        2. attach previous test report
   2. move to the next environment (if validated release)


#### ***Reactive***
actions that are triggered by other actions

 - On dependency update (in multi-repo projects):
   - NPM (must be interruptible)
   - for each:
       1. clone
       2. update dependency
       3. build
       4. test
       5. trigger `dev` release
   - if part of multi repo (bundled) lib:
       - update bundles with latest version
   - Docker:
       - trigger dev deploy in docker/kubernetes env (start deployment test circus)

- On dependency update (non managed)
  1. update dependency
  2. run build
  3. run tests
  4. auto generate non validated release
 

 - On Specific Libs update (angular, ionic, react, etc:
   1. update dependency
   2. run build
   3. run tests (including e2e)
   4. update compatibility matrix
   5. trigger non dev release